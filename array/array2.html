<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <p id="demo"></p>
    <script>
      // 배열
      // 다양한 타입의 값을 담을 수 있음
      const fruits = ["사과", "망고", "바나나", "수박", "자두", "포도"];
      const others = ["과일", 1, 3.14, new Date(), 35, {}];
      // 추가(push) - 뒤부터 넣어줌
      fruits.push("키위");
      console.log(fruits);
      // 추가(unshift) - 앞부터 넣어줌
      fruits.unshift("오렌지");
      console.log(fruits);

      fruits.splice(2, 0, "두리안"); // (인덱스위치 번호 , 삭제 카운트0 이면 삭제 X , 넣을 데이터)
      console.log(fruits);

      // 삭제

      // - POP <> PUSH , shift <> nushift

      fruits.pop(); // 마지막 요소 삭제
      console.log(fruits);

      fruits.shift(); // 첫 요소 삭제
      console.log(fruits);

      fruits.splice(2, 1); // 지정한 위치에 있는 요소 삭제
      console.log(fruits);

      // 배열 길이 - length

      console.log("배열길이  :", fruits.length);

      // toStrong() : 배열 요소를 STRONG 으로 변환해서 돌려줌 , 콤마로 구분해서 넣어줌

      document.getElementById("demo").innerHTML = fruits.toString();

      // join() 배열 요소를 연결해 하나의 값으로 돌려줌
      // 내가 원하는 기호로 돌려 받을때 사용

      document.write("배열 요소를 연결해 하나의 값으로 :", fruits.join("-"), "<br>");

      //sort() 오름차순 정렬 단 문자열만 가능()
      document.write("배열 요소 정렬 :", fruits.sort(), "<br>");

      const numbers = [12, 6, 9, 1, 10, 7];
      document.write("숫자 요소 정렬 :", numbers.sort(), "<br>");
      // 직접 비교 함수 작성 필요
      numbers.sort((a, b) => b - a); // 내림차순
      numbers.sort((a, b) => a - b); // 오름 차순
      document.write(numbers, "<br>");

      document.write("배열 거꾸로 출력 :", fruits.reverse(), "<br>");

      // concat()

      document.write("다른 배열과 연걸 :", fruits.concat("석류"), "<br>");

      // 배열 요소 찾기 : indexof() lastindexof(), lncludes()
      document.write("배열 요소의 인덱스 찾기", fruits.indexOf("사과"), "<br>");
      document.write("배열 요소의 인덱스 찾기", fruits.indexOf("파파야"), "<br>"); // 없는 요소를 찾으라고 했기에  -1 을 돌려준다
      document.write("배열 요소 찾기", fruits.includes("사과"), "<br>"); // 포함하고 있는지에 대한 여부를 묻는 거라 TRUE ,FLASE로 돌려 준다

      //                              find(함수), findindex(함수) ,findlast(함수) findlastindex(함수)
      // numbers = [12, 6, 9, 1, 10, 7];

      document.write(
        "배열 요소 찾기",
        numbers.find((num) => num > 5),
        "<br>"
      ); // 넘버스 배열에서 5보다 큰 숫자를 찾아줘 단 한번만 찾아줌 첫번째로 오는

      document.write(
        "배열 요소 찾기",
        numbers.findIndex((num) => num > 5),
        "<br>"
      ); // 조건에 만족하는 요소에 위치

      // ... (spread) :  배열에 있는 요소들을 하나씩 뽑아서 새로운 배열로 돌려준다
      //   배열의 깊은 복사 (원본 하고는 상관 없음)

      //   배열에 있는 요소들을 하나씩 뽑아서 담아준다

      let shallowCopy = [...fruits];
      document.write("배열 shallowCopy ", shallowCopy, "<br>");

      fruits.push("파인애플");
      document.write("배열 fruits ", fruits, "<br>");
      document.write("배열 shallowCopy ", shallowCopy, "<br>"); // 원본에 추가한 요소는 카피본에 반영 되지않음

      const fruits2 = fruits; // 해당 방식으로 카피하면 원본도 영향이 간다 이유는 주소만 복사하는 개념이기에 같은 결과 값을 가진다
      //   배열의 얕은 복사 (원본 하고 상관 있음)
      document.write("배열 fruits2 ", fruits2, "<br>");
      fruits.push("고구마");
      document.write("배열 fruits ", fruits, "<br>");
      document.write("배열 fruits2 ", fruits2, "<br>");

      const arr1 = ["1월", "2월", "3월"];
      const arr2 = ["4월", "5월", "6월"];
      const arr3 = ["7월", "8월", "9월"];
      const months = [...arr1, ...arr2, ...arr3];
      document.write("배열 monts ", months, "<br>");

      // 동일한 값으로 배열 생성 - fill() 메소드

      const arr4 = [1, 1, 1, 1, 1];
      const arr5 = new Array(5).fill(1); // 5칸 공간 인덱스 배열 생성 () 안에 채우고싶은 데이터 입력
      document.write("배열 arr5 ", arr5, "<br>");
    </script>
  </body>
</html>
